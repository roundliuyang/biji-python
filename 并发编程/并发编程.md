# 并发编程

>[并发编程](https://python3-cookbook.readthedocs.io/zh-cn/latest/chapters/p12_concurrency.html)
>[[Python多线程]with语句加锁Lock](https://zhuanlan.zhihu.com/p/360604465)

## 给关键部分加锁

### 问题

你需要对多线程程序中的临界区加锁以避免竞争条件。

### 解决方案

要在多线程程序中安全使用可变对象，你需要使用 threading 库中的 `Lock` 对象，就像下边这个例子这样：

```python
import threading

class SharedCounter:
    '''
    A counter object that can be shared by multiple threads.
    '''
    def __init__(self, initial_value = 0):
        self._value = initial_value
        self._value_lock = threading.Lock()

    def incr(self,delta=1):
        '''
        Increment the counter with locking
        '''
        with self._value_lock:
             self._value += delta

    def decr(self,delta=1):
        '''
        Decrement the counter with locking
        '''
        with self._value_lock:
             self._value -= delta
```

`Lock` 对象和 `with` 语句块一起使用可以保证互斥执行，就是每次只有一个线程可以执行 with 语句包含的代码块。with 语句会在这个代码块执行前自动获取锁，在执行结束后自动释放锁。

Python [Threading](https://zhida.zhihu.com/search?content_id=168263641&content_type=Article&match_order=1&q=Threading&zhida_source=entity)中的[Lock](https://zhida.zhihu.com/search?content_id=168263641&content_type=Article&match_order=1&q=Lock&zhida_source=entity)模块有[acquire()](https://zhida.zhihu.com/search?content_id=168263641&content_type=Article&match_order=1&q=acquire()&zhida_source=entity)和[release()](https://zhida.zhihu.com/search?content_id=168263641&content_type=Article&match_order=1&q=release()&zhida_source=entity)两种方法，这两种方法与[with语句](https://zhida.zhihu.com/search?content_id=168263641&content_type=Article&match_order=1&q=with语句&zhida_source=entity)的搭配相当于，进入with语句块时候会先执行acquire()方法，语句块结束后会执行release方法。

举个例子：

```python
from threading import Lock

temp_lock = Lock()

with temp_lock:
   print(temp_lock)
   # 输出是 <locked _thread.lock object at 0x10e304870> 说明temp_lock上锁了

print(temp_lock)
# 输出是<unlocked _thread.lock object at 0x10e304870> 说明temp_lock被释放了
```

现在来解析一下with语句：

```python
with temp_lock:
    # do something...
```

相当于以下代码：

```python
temp_lock.acquire()
try:
   # do something...
finally:
   temp_lock.release()
```

也就是在运行的时候对语句块的内容上锁了，运行完后再释放了这个锁。

在with语句中使用锁Lock，就不用显性地使用acquire()和release()方法。





